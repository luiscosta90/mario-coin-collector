<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Mario Coin Collector</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
            background: #87CEEB;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-image: 
                linear-gradient(45deg, #5c8d5c 25%, transparent 25%),
                linear-gradient(-45deg, #5c8d5c 25%, transparent 25%),
                linear-gradient(45deg, transparent 75%, #5c8d5c 75%),
                linear-gradient(-45deg, transparent 75%, #5c8d5c 75%);
            background-size: 20px 20px;
            background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
            background-color: #5c8d5c;
            touch-action: none;
        }
        #gameContainer {
            display: none;
            text-align: center;
            background: rgba(255, 255, 255, 0.9);
            padding: 10px;
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(0,0,0,0.2);
            margin: 10px auto;
            max-width: 100%;
            width: 100%;
            box-sizing: border-box;
        }
        canvas {
            border: 3px solid #8B4513;
            background: #90EE90;
            border-radius: 5px;
            box-shadow: 0 0 10px rgba(0,0,0,0.2);
            margin: 10px auto;
            display: block;
            max-width: 100%;
            height: auto;
        }
        #score {
            font-size: 20px;
            font-weight: bold;
            margin-bottom: 10px;
            display: flex;
            gap: 10px;
            justify-content: center;
            flex-wrap: wrap;
        }
        .score-item {
            background: #f0f0f0;
            padding: 5px 10px;
            border-radius: 5px;
            border: 2px solid #8B4513;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        h2 {
            color: #8B4513;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 10px;
            font-size: 24px;
        }
        p {
            color: #333;
            font-size: 16px;
            margin: 5px 0;
        }
        #playerNameDisplay {
            font-weight: bold;
            color: #8B4513;
        }
        #menu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            background: rgba(255, 255, 255, 0.95);
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 0 20px rgba(0,0,0,0.2);
            border: 3px solid #8B4513;
            width: 90%;
            max-width: 400px;
            box-sizing: border-box;
        }
        .menu-button {
            display: block;
            width: 100%;
            padding: 15px;
            margin: 10px auto;
            font-size: 18px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            touch-action: manipulation;
        }
        .menu-button:hover {
            background: #45a049;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }
        .player-name-input {
            width: 100%;
            padding: 10px;
            margin: 10px auto;
            font-size: 16px;
            border: 2px solid #4CAF50;
            border-radius: 5px;
            display: block;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            box-sizing: border-box;
        }
        #rankings {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 255, 255, 0.95);
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 0 20px rgba(0,0,0,0.2);
            max-height: 80vh;
            overflow-y: auto;
            border: 3px solid #8B4513;
            width: 90%;
            max-width: 400px;
            box-sizing: border-box;
        }
        .ranking-item {
            padding: 10px;
            margin: 5px 0;
            background: #f0f0f0;
            border-radius: 5px;
            border: 1px solid #8B4513;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            font-size: 14px;
        }
        .back-button {
            background: #f44336;
            margin-top: 10px;
        }
        .back-button:hover {
            background: #da190b;
        }
        #touchControls {
            display: none;
            position: fixed;
            bottom: 20px;
            left: 20px;
            width: 150px;
            height: 150px;
            z-index: 1000;
            pointer-events: none;
        }
        .joystick {
            position: absolute;
            width: 150px;
            height: 150px;
            background: rgba(255, 255, 255, 0.8);
            border: 3px solid #8B4513;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            pointer-events: auto;
            touch-action: none;
        }
        .joystick-knob {
            position: absolute;
            width: 60px;
            height: 60px;
            background: rgba(255, 255, 255, 0.9);
            border: 2px solid #8B4513;
            border-radius: 50%;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            pointer-events: none;
            transition: transform 0.1s;
            transform-origin: center;
        }
        @media (min-width: 768px) {
            #touchControls {
                display: none;
            }
        }
        @media (max-width: 767px) {
            #touchControls {
                display: block;
            }
            canvas {
                width: 100%;
                height: auto;
                max-height: 60vh;
            }
            .score-item {
                font-size: 16px;
                padding: 8px 12px;
            }
            #gameContainer {
                padding-bottom: 180px;
                margin: 0;
                border-radius: 0;
            }
            #menu {
                width: 95%;
                padding: 15px;
            }
            .menu-button {
                padding: 12px;
                font-size: 16px;
            }
            h2 {
                font-size: 20px;
            }
            p {
                font-size: 14px;
            }
        }
    </style>
    <script>
        // Global game object to store game state and functions
        const game = {
            started: false,
            animationFrameId: null,
            rankings: JSON.parse(localStorage.getItem('rankings')) || [],
            playerName: '',
            canvas: null,
            ctx: null,
            coinCountElement: null,
            pointCountElement: null,
            timerElement: null,
            coinSound: null,
            mario: null,
            imageLoaded: false,
            player: null,
            coins: [],
            score: 0,
            coinsCollected: 0,
            maxCoins: 8,
            lastCoinSpawn: 0,
            coinSpawnInterval: 3000,
            coinSize: 20,
            gameTime: 60, // 60 segundos
            timeLeft: 60,
            gameStartTime: 0,
            lastCoinCollectionTime: 0,
            baseScore: 100,
            maxMultiplier: 3,
            currentMultiplier: 1,
            multiplierDisplay: null,
            keys: {
                ArrowLeft: false,
                ArrowRight: false,
                ArrowUp: false,
                ArrowDown: false
            },
            obstacles: [],
            lastObstacleUpdate: 0,
            obstacleUpdateInterval: 15000 // 15 segundos
        };

        // Adicionar listener para o campo de nome
        document.addEventListener('DOMContentLoaded', function() {
            const nameInput = document.getElementById('playerName');
            const clearScoresButton = document.getElementById('clearScoresButton');
            
            // Garantir que o bot√£o est√° oculto inicialmente
            clearScoresButton.style.display = 'none';
            
            nameInput.addEventListener('input', function(e) {
                if (e.target.value.trim() === 'clearscores') {
                    clearScoresButton.style.display = 'block';
                } else {
                    clearScoresButton.style.display = 'none';
                }
            });
        });

        // Global functions that need to be accessible from HTML
        function startGame() {
            const nameInput = document.getElementById('playerName');
            const clearScoresButton = document.getElementById('clearScoresButton');
            const playerName = nameInput.value.trim();
            
            if (!playerName) {
                alert('Por favor, insira seu nome antes de come√ßar!');
                return;
            }

            // Verificar se o nome √© "clearscores"
            if (playerName === 'clearscores') {
                if (confirm('Tem certeza que deseja limpar todas as pontua√ß√µes?')) {
                    const scoresRef = firebase.database().ref('scores');
                    scoresRef.remove()
                        .then(() => {
                            console.log('Pontua√ß√µes limpas com sucesso!');
                            alert('Todas as pontua√ß√µes foram limpas!');
                            // Limpar o campo de nome
                            nameInput.value = '';
                            // Esconder o bot√£o de limpar pontua√ß√µes
                            clearScoresButton.style.display = 'none';
                            // Atualizar a exibi√ß√£o dos rankings
                            game.updateRankingsDisplay();
                            return;
                        })
                        .catch((error) => {
                            console.error('Erro ao limpar pontua√ß√µes:', error);
                            alert('Erro ao limpar pontua√ß√µes. Tente novamente.');
                            return;
                        });
                }
                return;
            }
            
            game.playerName = playerName;
            document.getElementById('playerNameDisplay').textContent = playerName;
            document.getElementById('menu').style.display = 'none';
            document.getElementById('gameContainer').style.display = 'block';
            game.started = true;
            game.resetGame();
            game.startGameLoop();
        }

        function showRankings() {
            document.getElementById('menu').style.display = 'none';
            document.getElementById('rankings').style.display = 'block';
            game.updateRankingsDisplay();
        }

        function hideRankings() {
            document.getElementById('rankings').style.display = 'none';
            document.getElementById('menu').style.display = 'block';
        }

        function clearHighScores() {
            if (confirm('Are you sure you want to clear all high scores? This action cannot be undone.')) {
                const scoresRef = firebase.database().ref('scores');
                scoresRef.remove()
                    .then(() => {
                        console.log('High scores cleared successfully!');
                        alert('High scores have been cleared!');
                        game.updateRankingsDisplay(); // Refresh the display
                    })
                    .catch((error) => {
                        console.error('Error clearing high scores:', error);
                        alert('Error clearing high scores. Please try again.');
                    });
            }
        }

        // Initialize game when DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            // Initialize game elements
            game.canvas = document.getElementById('gameCanvas');
            game.ctx = game.canvas.getContext('2d');
            game.coinCountElement = document.getElementById('coinCount');
            game.pointCountElement = document.getElementById('pointCount');
            game.timerElement = document.getElementById('timer');
            game.multiplierDisplay = document.getElementById('multiplier');

            // Ajustar tamanho do canvas para mobile
            function resizeCanvas() {
                const maxWidth = window.innerWidth - 20;
                const maxHeight = window.innerHeight - 200;
                const scale = Math.min(maxWidth / 800, maxHeight / 400);
                game.canvas.width = 800 * scale;
                game.canvas.height = 400 * scale;
                
                // Ajustar posi√ß√£o do jogador ap√≥s redimensionamento
                if (game.player) {
                    game.player.x = 50 * scale;
                    game.player.y = (game.canvas.height - 100) * scale;
                    game.player.width = 48 * scale;
                    game.player.height = 64 * scale;
                }
                
                // Ajustar controles touch para mobile
                const touchControls = document.getElementById('touchControls');
                if (window.innerWidth <= 767) {
                    touchControls.style.display = 'block';
                    const buttons = touchControls.getElementsByClassName('touch-button');
                    for (let button of buttons) {
                        button.style.width = `${70 * scale}px`;
                        button.style.height = `${70 * scale}px`;
                        button.style.fontSize = `${32 * scale}px`;
                    }
                } else {
                    touchControls.style.display = 'none';
                }
            }
            
            // Chamar resizeCanvas inicialmente e quando a janela for redimensionada
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);

            // Touch controls
            const joystick = document.querySelector('.joystick');
            const knob = document.querySelector('.joystick-knob');
            let isDragging = false;
            let startX, startY;
            let currentX, currentY;
            const maxDistance = 45; // Dist√¢ncia m√°xima que o knob pode se mover

            function handleTouchStart(e) {
                e.preventDefault();
                isDragging = true;
                const touch = e.touches[0];
                const rect = joystick.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;
                
                startX = touch.clientX - centerX;
                startY = touch.clientY - centerY;
                updateKnobPosition(startX, startY);
            }

            function handleTouchMove(e) {
                if (!isDragging) return;
                e.preventDefault();
                const touch = e.touches[0];
                const rect = joystick.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;
                
                currentX = touch.clientX - centerX;
                currentY = touch.clientY - centerY;
                updateKnobPosition(currentX, currentY);
            }

            function handleTouchEnd(e) {
                if (!isDragging) return;
                e.preventDefault();
                isDragging = false;
                resetKnobPosition();
                // Reset movement
                game.keys.ArrowLeft = false;
                game.keys.ArrowRight = false;
                game.keys.ArrowUp = false;
                game.keys.ArrowDown = false;
            }

            function updateKnobPosition(x, y) {
                // Calcular a dist√¢ncia do centro
                const distance = Math.sqrt(x * x + y * y);

                // Limitar a dist√¢ncia
                if (distance > maxDistance) {
                    const angle = Math.atan2(y, x);
                    x = Math.cos(angle) * maxDistance;
                    y = Math.sin(angle) * maxDistance;
                }

                // Atualizar posi√ß√£o do knob
                knob.style.transform = `translate(${x}px, ${y}px)`;

                // Calcular dire√ß√£o do movimento
                const threshold = 20; // Limiar para considerar movimento
                if (Math.abs(x) > threshold) {
                    game.keys.ArrowLeft = x < 0;
                    game.keys.ArrowRight = x > 0;
                }
                if (Math.abs(y) > threshold) {
                    game.keys.ArrowUp = y < 0;
                    game.keys.ArrowDown = y > 0;
                }
            }

            function resetKnobPosition() {
                knob.style.transform = 'translate(0px, 0px)';
            }

            // Adicionar eventos touch para o joystick
            joystick.addEventListener('touchstart', handleTouchStart, { passive: false });
            joystick.addEventListener('touchmove', handleTouchMove, { passive: false });
            joystick.addEventListener('touchend', handleTouchEnd, { passive: false });
            joystick.addEventListener('touchcancel', handleTouchEnd, { passive: false });

            // Prevent default touch behaviors
            document.addEventListener('touchmove', (e) => {
                if (e.target.closest('.joystick')) {
                    e.preventDefault();
                }
            }, { passive: false });

            // Create coin sound
            game.coinSound = new Audio('https://assets.mixkit.co/active_storage/sfx/2013/2013-preview.mp3');
            game.coinSound.volume = 0.2;

            // Create Mario sprite
            game.mario = new Image();
            game.mario.src = 'mario.png';
            
            game.mario.onload = function() {
                game.imageLoaded = true;
                console.log("Mario sprite loaded successfully!");
            };
            
            game.mario.onerror = function() {
                console.log("Failed to load Mario sprite, using red square instead");
            };

            // Initialize player
            game.player = {
                x: 50,
                y: game.canvas.height - 100,
                width: 48,
                height: 64,
                speed: 0,
                maxSpeed: 5,
                acceleration: 0.5,
                deceleration: 0.3,
                direction: 'right',
                velocityX: 0,
                velocityY: 0
            };

            // Add event listeners for keyboard input
            document.addEventListener('keydown', function(e) {
                if (game.keys.hasOwnProperty(e.key)) {
                    game.keys[e.key] = true;
                    // Prevent default scroll behavior for arrow keys
                    if (e.key.startsWith('Arrow')) {
                        e.preventDefault();
                    }
                }
            });

            document.addEventListener('keyup', function(e) {
                if (game.keys.hasOwnProperty(e.key)) {
                    game.keys[e.key] = false;
                }
            });

            // Add game methods to the game object
            game.updatePlayerMovement = function() {
                // Horizontal movement
                if (this.keys.ArrowLeft) {
                    this.player.velocityX -= this.player.acceleration;
                    this.player.direction = 'left';
                } else if (this.keys.ArrowRight) {
                    this.player.velocityX += this.player.acceleration;
                    this.player.direction = 'right';
                } else {
                    // Apply deceleration when no keys are pressed
                    if (this.player.velocityX > 0) {
                        this.player.velocityX = Math.max(0, this.player.velocityX - this.player.deceleration);
                    } else if (this.player.velocityX < 0) {
                        this.player.velocityX = Math.min(0, this.player.velocityX + this.player.deceleration);
                    }
                }

                // Vertical movement
                if (this.keys.ArrowUp) {
                    this.player.velocityY -= this.player.acceleration;
                } else if (this.keys.ArrowDown) {
                    this.player.velocityY += this.player.acceleration;
                } else {
                    // Apply deceleration when no keys are pressed
                    if (this.player.velocityY > 0) {
                        this.player.velocityY = Math.max(0, this.player.velocityY - this.player.deceleration);
                    } else if (this.player.velocityY < 0) {
                        this.player.velocityY = Math.min(0, this.player.velocityY + this.player.deceleration);
                    }
                }

                // Limit speed
                this.player.velocityX = Math.max(-this.player.maxSpeed, Math.min(this.player.maxSpeed, this.player.velocityX));
                this.player.velocityY = Math.max(-this.player.maxSpeed, Math.min(this.player.maxSpeed, this.player.velocityY));

                // Update position with sliding
                let newX = this.player.x + this.player.velocityX;
                let newY = this.player.y + this.player.velocityY;

                // Limitar movimento dentro dos limites do canvas
                newX = Math.max(-this.player.width, Math.min(newX, this.canvas.width));
                newY = Math.max(-this.player.height, Math.min(newY, this.canvas.height));

                // Create a temporary player object for collision detection
                let tempPlayer = {
                    x: newX,
                    y: newY,
                    width: this.player.width,
                    height: this.player.height
                };

                // Check collision with obstacles
                let hasCollision = false;

                // Check horizontal movement first
                tempPlayer.x = newX;
                tempPlayer.y = this.player.y;
                for (let obstacle of this.obstacles) {
                    if (this.checkCollision(tempPlayer, obstacle)) {
                        hasCollision = true;
                        // Stop horizontal movement
                        this.player.velocityX = 0;
                        // Try to slide vertically
                        if (this.player.velocityY !== 0) {
                            newY = this.player.y + this.player.velocityY;
                            tempPlayer.y = newY;
                            if (!this.checkCollision(tempPlayer, obstacle)) {
                                this.player.y = newY;
                            }
                        }
                    }
                }

                // Check vertical movement
                tempPlayer.x = this.player.x;
                tempPlayer.y = newY;
                for (let obstacle of this.obstacles) {
                    if (this.checkCollision(tempPlayer, obstacle)) {
                        hasCollision = true;
                        // Stop vertical movement
                        this.player.velocityY = 0;
                        // Try to slide horizontally
                        if (this.player.velocityX !== 0) {
                            newX = this.player.x + this.player.velocityX;
                            tempPlayer.x = newX;
                            if (!this.checkCollision(tempPlayer, obstacle)) {
                                this.player.x = newX;
                            }
                        }
                    }
                }

                // Update position if no collision
                if (!hasCollision) {
                    this.player.x = newX;
                    this.player.y = newY;
                }
            };

            game.createCoin = function() {
                let coin;
                let validPosition = false;
                let attempts = 0;
                const maxAttempts = 20; // Aumentado para ter mais tentativas de encontrar uma posi√ß√£o v√°lida

                while (!validPosition && attempts < maxAttempts) {
                    coin = {
                        x: Math.random() * (this.canvas.width - this.coinSize),
                        y: Math.random() * (this.canvas.height - this.coinSize),
                        width: this.coinSize,
                        height: this.coinSize
                    };

                    // Verificar colis√£o com obst√°culos e outras moedas
                    validPosition = true;
                    
                    // Verificar colis√£o com obst√°culos
                    for (let obstacle of this.obstacles) {
                        if (this.checkCollision(coin, obstacle)) {
                            validPosition = false;
                            break;
                        }
                    }

                    // Verificar colis√£o com outras moedas
                    if (validPosition) {
                        for (let existingCoin of this.coins) {
                            if (this.checkCollision(coin, existingCoin)) {
                                validPosition = false;
                                break;
                            }
                        }
                    }

                    attempts++;
                }

                if (validPosition) {
                    this.coins.push(coin);
                } else {
                    console.log("N√£o foi poss√≠vel encontrar uma posi√ß√£o v√°lida para a moeda");
                }
            };

            game.checkCollision = function(player, object) {
                return player.x < object.x + object.width &&
                       player.x + player.width > object.x &&
                       player.y < object.y + object.height &&
                       player.y + player.height > object.y;
            };

            game.generateObstacles = function() {
                // Limpar obst√°culos existentes
                this.obstacles = [];
                
                // Fun√ß√£o auxiliar para verificar se um obst√°culo colide com o jogador
                const checkPlayerCollision = (obstacle) => {
                    return this.checkCollision(this.player, obstacle);
                };

                // Fun√ß√£o para verificar colis√£o entre obst√°culos
                const checkObstacleCollision = (newObstacle) => {
                    return this.obstacles.some(existingObstacle => 
                        this.checkCollision(newObstacle, existingObstacle)
                    );
                };

                // Fun√ß√£o para tentar criar um obst√°culo v√°lido
                const createValidObstacle = (x, y, width, height, maxAttempts = 5) => {
                    let attempts = 0;
                    while (attempts < maxAttempts) {
                        const obstacle = {
                            x: x,
                            y: y,
                            width: width,
                            height: height
                        };
                        
                        // Verificar colis√£o com o jogador e outros obst√°culos
                        if (!checkPlayerCollision(obstacle) && !checkObstacleCollision(obstacle)) {
                            return obstacle;
                        }
                        
                        // Ajustar posi√ß√£o se houver colis√£o
                        if (Math.random() > 0.5) {
                            x = Math.random() * (this.canvas.width - width) + 50;
                        } else {
                            y = Math.random() * (this.canvas.height - height) + 50;
                        }
                        attempts++;
                    }
                    return null;
                };
                
                // Criar novos obst√°culos
                // Parede superior
                const topWall = createValidObstacle(
                    Math.random() * (this.canvas.width - 200) + 50,
                    50,
                    200,
                    20
                );
                if (topWall) this.obstacles.push(topWall);
                
                // Parede inferior
                const bottomWall = createValidObstacle(
                    Math.random() * (this.canvas.width - 200) + 50,
                    this.canvas.height - 70,
                    200,
                    20
                );
                if (bottomWall) this.obstacles.push(bottomWall);
                
                // Paredes verticais
                const leftWall = createValidObstacle(
                    Math.random() * (this.canvas.width - 100) + 50,
                    50,
                    20,
                    200
                );
                if (leftWall) this.obstacles.push(leftWall);
                
                const rightWall = createValidObstacle(
                    Math.random() * (this.canvas.width - 100) + 50,
                    this.canvas.height - 250,
                    20,
                    200
                );
                if (rightWall) this.obstacles.push(rightWall);
                
                // Adicionar alguns obst√°culos aleat√≥rios
                const numRandomObstacles = Math.floor(Math.random() * 3) + 2; // 2-4 obst√°culos aleat√≥rios
                for (let i = 0; i < numRandomObstacles; i++) {
                    const isVertical = Math.random() > 0.5;
                    const randomObstacle = createValidObstacle(
                        Math.random() * (this.canvas.width - (isVertical ? 20 : 100)) + 50,
                        Math.random() * (this.canvas.height - (isVertical ? 100 : 20)) + 50,
                        isVertical ? 20 : 100,
                        isVertical ? 100 : 20
                    );
                    if (randomObstacle) this.obstacles.push(randomObstacle);
                }
            };

            game.updateObstacles = function(timestamp) {
                if (timestamp - this.lastObstacleUpdate >= this.obstacleUpdateInterval) {
                    this.generateObstacles();
                    this.lastObstacleUpdate = timestamp;
                }
            };

            game.gameLoop = function(timestamp) {
                if (!this.started) return;

                // Update timer
                const elapsedTime = Math.floor((timestamp - this.gameStartTime) / 1000);
                this.timeLeft = Math.max(0, this.gameTime - elapsedTime);
                this.timerElement.textContent = this.timeLeft;

                // Check if time is up
                if (this.timeLeft <= 0) {
                    this.gameOver();
                    return;
                }

                // Update obstacles layout
                this.updateObstacles(timestamp);

                // Clear canvas
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

                // Draw obstacles (brick walls)
                this.ctx.fillStyle = '#8B4513';
                this.obstacles.forEach(obstacle => {
                    this.ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);
                    // Add brick pattern
                    this.ctx.strokeStyle = '#A0522D';
                    this.ctx.lineWidth = 2;
                    for (let x = obstacle.x; x < obstacle.x + obstacle.width; x += 20) {
                        for (let y = obstacle.y; y < obstacle.y + obstacle.height; y += 10) {
                            this.ctx.strokeRect(x, y, 20, 10);
                        }
                    }
                });

                // Update player movement
                this.updatePlayerMovement();

                // Check if it's time to spawn a new coin
                if (timestamp - this.lastCoinSpawn >= this.coinSpawnInterval && this.coins.length < this.maxCoins) {
                    this.createCoin();
                    this.lastCoinSpawn = timestamp;
                }

                // Draw coins
                this.ctx.fillStyle = 'gold';
                this.coins.forEach(coin => {
                    this.ctx.beginPath();
                    this.ctx.arc(coin.x + coin.width/2, coin.y + coin.height/2, coin.width/2, 0, Math.PI * 2);
                    this.ctx.fill();
                    this.ctx.closePath();
                });

                // Draw player (Mario or red square)
                if (this.imageLoaded) {
                    this.ctx.save();
                    if (this.player.direction === 'left') {
                        this.ctx.scale(-1, 1);
                        this.ctx.translate(-this.player.x - this.player.width, this.player.y);
                    } else {
                        this.ctx.translate(this.player.x, this.player.y);
                    }
                    this.ctx.drawImage(this.mario, 0, 0, this.player.width, this.player.height);
                    this.ctx.restore();
                } else {
                    // Draw red square as fallback
                    this.ctx.fillStyle = 'red';
                    this.ctx.fillRect(this.player.x, this.player.y, this.player.width, this.player.height);
                }

                // Check for coin collection
                this.coins = this.coins.filter(coin => {
                    if (this.checkCollision(this.player, coin)) {
                        this.coinsCollected++;
                        
                        // Calcular tempo desde a √∫ltima moeda coletada
                        const currentTime = performance.now();
                        const timeSinceLastCoin = currentTime - this.lastCoinCollectionTime;
                        this.lastCoinCollectionTime = currentTime;

                        // Calcular multiplicador baseado no tempo
                        if (timeSinceLastCoin < 2000) { // Menos de 2 segundos
                            this.currentMultiplier = Math.min(this.maxMultiplier, this.currentMultiplier + 0.5);
                        } else if (timeSinceLastCoin > 4000) { // Mais de 4 segundos
                            this.currentMultiplier = Math.max(1, this.currentMultiplier - 0.5);
                        }

                        // Calcular pontua√ß√£o com multiplicador
                        const pointsEarned = Math.round(this.baseScore * this.currentMultiplier);
                        this.score += pointsEarned;

                        // Atualizar displays
                        this.coinCountElement.textContent = this.coinsCollected;
                        this.pointCountElement.textContent = this.score;
                        this.multiplierDisplay.textContent = this.currentMultiplier.toFixed(1) + 'x';
                        
                        // Play coin sound
                        this.coinSound.currentTime = 0;
                        this.coinSound.play().catch(error => {
                            console.log("Sound play failed:", error);
                        });
                        
                        // Check if player has collected 10 coins
                        if (this.coinsCollected >= 10) {
                            console.log("10 moedas coletadas! Chamando gameOver...");
                            this.started = false;
                            if (this.animationFrameId) {
                                cancelAnimationFrame(this.animationFrameId);
                            }
                            this.gameOver();
                            return false;
                        }
                        
                        return false;
                    }
                    return true;
                });

                // Continue game loop
                this.animationFrameId = requestAnimationFrame(this.gameLoop.bind(this));
            };

            game.startGameLoop = function() {
                if (!this.started) return;
                this.animationFrameId = requestAnimationFrame(this.gameLoop.bind(this));
            };

            game.resetGame = function() {
                // Reset game state
                this.coins = [];
                this.score = 0;
                this.coinsCollected = 0;
                this.lastCoinSpawn = performance.now();
                this.lastObstacleUpdate = performance.now();
                this.timeLeft = this.gameTime;
                this.gameStartTime = performance.now();
                this.lastCoinCollectionTime = performance.now();
                this.currentMultiplier = 1;
                this.coinCountElement.textContent = '0';
                this.pointCountElement.textContent = '0';
                this.timerElement.textContent = this.timeLeft;
                this.multiplierDisplay.textContent = '1x';
                
                // Reset player position
                this.player.x = 50;
                this.player.y = this.canvas.height - 100;
                this.player.velocityX = 0;
                this.player.velocityY = 0;

                // Generate initial obstacles
                this.generateObstacles();
            };

            game.updateRankingsDisplay = function() {
                const rankingsList = document.getElementById('rankingsList');
                rankingsList.innerHTML = '';
                
                console.log('Buscando pontua√ß√µes do Firebase...');
                
                // Buscar pontua√ß√µes do Firebase
                const scoresRef = firebase.database().ref('scores');
                scoresRef.orderByChild('score').limitToLast(10).once('value')
                    .then((snapshot) => {
                        console.log('Dados recebidos do Firebase:', snapshot.val());
                        const scores = [];
                        snapshot.forEach((childSnapshot) => {
                            scores.push(childSnapshot.val());
                        });
                        
                        // Ordenar por pontua√ß√£o (maior primeiro)
                        scores.sort((a, b) => b.score - a.score);
                        
                        // Exibir pontua√ß√µes
                        scores.forEach((score, index) => {
                            const div = document.createElement('div');
                            div.className = 'ranking-item';
                            div.textContent = `${index + 1}. ${score.name} - Score: ${score.score} - Coins: ${score.coins} - Date: ${new Date(score.date).toLocaleDateString()}`;
                            rankingsList.appendChild(div);
                        });
                    })
                    .catch((error) => {
                        console.error("Erro ao carregar pontua√ß√µes:", error);
                        rankingsList.innerHTML = '<div class="ranking-item">Erro ao carregar pontua√ß√µes</div>';
                    });
            };

            game.saveScore = function(score, coins) {
                // Salvar no Firebase
                const scoresRef = firebase.database().ref('scores');
                const newScore = {
                    name: this.playerName,
                    score: score,
                    coins: coins,
                    date: new Date().toISOString()
                };
                
                console.log('Tentando salvar pontua√ß√£o:', newScore);
                
                scoresRef.push(newScore)
                    .then(() => {
                        console.log('Pontua√ß√£o salva com sucesso!');
                    })
                    .catch((error) => {
                        console.error('Erro ao salvar pontua√ß√£o:', error);
                    });
            };

            game.gameOver = function() {
                console.log("Game Over chamado!");
                this.started = false;
                if (this.animationFrameId) {
                    cancelAnimationFrame(this.animationFrameId);
                }
                this.saveScore(this.score, this.coinsCollected);
                
                // Remover qualquer popup existente
                const existingPopup = document.querySelector('.game-over-popup');
                if (existingPopup) {
                    existingPopup.remove();
                }
                
                // Criar e mostrar o popup
                const popup = document.createElement('div');
                popup.className = 'game-over-popup';
                popup.style.position = 'fixed';
                popup.style.top = '50%';
                popup.style.left = '50%';
                popup.style.transform = 'translate(-50%, -50%)';
                popup.style.backgroundColor = 'rgba(255, 255, 255, 0.95)';
                popup.style.padding = '20px';
                popup.style.borderRadius = '15px';
                popup.style.boxShadow = '0 0 20px rgba(0,0,0,0.2)';
                popup.style.border = '3px solid #8B4513';
                popup.style.zIndex = '1000';
                popup.style.textAlign = 'center';
                popup.style.maxWidth = '90%';
                popup.style.width = '400px';
                
                const message = this.timeLeft <= 0 ? 
                    `Tempo esgotado, ${this.playerName}! ‚è∞` :
                    `Parab√©ns ${this.playerName}! üéâ\nVoc√™ completou a miss√£o!`;
                
                popup.innerHTML = `
                    <h2 style="color: #8B4513; margin-bottom: 15px; white-space: pre-line;">${message}</h2>
                    <div style="margin: 20px 0; font-size: 18px;">
                        <p style="margin: 10px 0;">Pontua√ß√£o: ${this.score}</p>
                        <p style="margin: 10px 0;">Moedas Coletadas: ${this.coinsCollected}</p>
                    </div>
                    <button class="menu-button" onclick="this.parentElement.remove(); document.getElementById('gameContainer').style.display = 'none'; document.getElementById('menu').style.display = 'block';">
                        Voltar ao Menu
                    </button>
                `;
                
                document.body.appendChild(popup);
                console.log("Popup adicionado ao DOM!");
            };

            // Add a console message to verify the game is running
            console.log("Game initialized successfully! Open browser console (F12) to see this message.");
        });
    </script>
</head>
<body>
    <div id="menu">
        <h1>Mario Coin Collector</h1>
        <input type="text" id="playerName" class="player-name-input" placeholder="Digite seu nome" maxlength="20">
        <button class="menu-button" onclick="startGame()">Start Game</button>
        <button class="menu-button" onclick="showRankings()">Rankings</button>
    </div>

    <div id="rankings">
        <h2>Top Scores</h2>
        <div id="rankingsList"></div>
        <button class="menu-button back-button" onclick="hideRankings()">Back to Menu</button>
        <button id="clearScoresButton" class="menu-button" style="background: #ff4444; display: none;" onclick="clearHighScores()">Clear High Scores</button>
    </div>

    <div id="gameContainer">
        <h2>Mario Coin Collector</h2>
        <div id="score">
            <div class="score-item">Moedas: <span id="coinCount">0</span></div>
            <div class="score-item">Pontos: <span id="pointCount">0</span></div>
            <div class="score-item">Tempo: <span id="timer">60</span>s</div>
            <div class="score-item">Multiplicador: <span id="multiplier">1x</span></div>
        </div>
        <p>Bem-vindo(a), <span id="playerNameDisplay"></span>!</p>
        <p>Colete 10 moedas douradas para vencer!</p>
        <canvas id="gameCanvas" width="800" height="400"></canvas>
    </div>
    <div id="touchControls">
        <div class="joystick">
            <div class="joystick-knob"></div>
        </div>
    </div>
    <!-- Firebase App (the core Firebase SDK) -->
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
    <!-- Firebase Database -->
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-database-compat.js"></script>

    <!-- Initialize Firebase -->
    <script>
        console.log('Iniciando configura√ß√£o do Firebase...');
        const firebaseConfig = {
            apiKey: "AIzaSyATr3QssfATVaFxx_QGc7J1Y6oaqgVrQWw",
            authDomain: "mario-coin-collector.firebaseapp.com",
            databaseURL: "https://mario-coin-collector-default-rtdb.europe-west1.firebasedatabase.app",
            projectId: "mario-coin-collector",
            storageBucket: "mario-coin-collector.firebasestorage.app",
            messagingSenderId: "712355001145",
            appId: "1:712355001145:web:d3c3a1e0ab8656e18a6ee8",
            measurementId: "G-B7ER8ZSNRK"
        };

        try {
            // Initialize Firebase
            firebase.initializeApp(firebaseConfig);
            const database = firebase.database();
            console.log('Firebase inicializado com sucesso!');
            
            // Teste de conex√£o
            const testRef = database.ref('test');
            testRef.set({
                timestamp: new Date().toISOString()
            }).then(() => {
                console.log('Conex√£o com Firebase estabelecida com sucesso!');
            }).catch((error) => {
                console.error('Erro ao conectar com Firebase:', error);
            });
        } catch (error) {
            console.error('Erro ao inicializar Firebase:', error);
        }
    </script>
</body>
</html>
